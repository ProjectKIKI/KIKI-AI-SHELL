#!/usr/bin/env python3
# LLM Shell (lsh) - 자연어 → bash 명령 비서형 쉘 (Python prototype)

import os
import sys
import json
import subprocess
from textwrap import dedent

import requests

# ------------------- 색상 정의 -------------------
RESET = "\033[0m"
GREEN = "\033[92m"   # LLM 관련 / 프롬프트
YELLOW = "\033[93m"  # 경고 / 안내
CYAN = "\033[96m"    # 정보
BOLD = "\033[1m"

# 색 끄기 옵션: export LSH_NO_COLOR=1
if os.environ.get("LSH_NO_COLOR", "0") == "1":
    RESET = GREEN = YELLOW = CYAN = BOLD = ""


# ------------------- LLM 설정 -------------------
DEFAULT_BASE_URL = "http://127.0.0.1:8082/v1/chat/completions"
DEFAULT_MODEL = "local-llama"

SYSTEM_PROMPT = dedent("""
당신은 Linux 쉘 어시스턴트입니다.

규칙:
- 사용자의 설명(한국어/영어)을 읽고 실행할 쉘 명령을 제안합니다.
- 반드시 JSON만 출력합니다. JSON 바깥에 아무 텍스트도 쓰지 마세요.
- JSON 형식:
  {
    "explanation": "무슨 일을 하는지 한국어로 짧게 설명",
    "commands": [
      "실행할_명령1",
      "실행할_명령2"
    ],
    "danger": true 또는 false
  }

- rm -rf /, :(){ :|:& };:, mkfs, dd로 디스크를 덮어쓰는 등 파괴적인 명령은 만들지 마세요.
- 파일/디렉터리 삭제, 시스템 설정 변경 명령은 꼭 필요할 때만 제안하고, 이 경우 "danger": true 로 표시하세요.
- 상대경로 대신 가능하면 절대경로를 사용하세요.
- 여러 명령이 필요하면 순서대로 "commands" 배열에 넣으세요.
""").strip()


def get_llm_config():
    base_url = os.environ.get("LSH_LLM_BASE_URL", DEFAULT_BASE_URL)
    model = os.environ.get("LSH_LLM_MODEL", DEFAULT_MODEL)
    return base_url, model


def call_llm(user_text: str) -> dict:
    """OpenAI 호환 llama.cpp 서버에 요청"""
    base_url, model = get_llm_config()

    payload = {
        "model": model,
        "messages": [
            {"role": "system", "content": SYSTEM_PROMPT},
            {"role": "user", "content": user_text},
        ],
        "temperature": 0.1,
    }

    resp = requests.post(base_url, json=payload, timeout=120)
    resp.raise_for_status()

    data = resp.json()
    content = data["choices"][0]["message"]["content"].strip()

    try:
        return json.loads(content)
    except json.JSONDecodeError as e:
        raise RuntimeError(f"LLM 응답을 JSON으로 파싱할 수 없습니다:\n{content}\n{e}")


def run_shell_command(cmd: str) -> int:
    """bash를 통해 단일 명령 실행"""
    completed = subprocess.run(
        cmd,
        shell=True,
        executable="/bin/bash",
    )
    return completed.returncode


DANGEROUS_PATTERNS = [
    "rm -rf /",
    "rm -rf /*",
    " mkfs",
    ":(){",
    " dd ",
    "shutdown",
    "poweroff",
    "reboot",
    "init 0",
    "init 6",
]


def looks_dangerous(cmds):
    text = "\n".join(cmds).lower()
    for pat in DANGEROUS_PATTERNS:
        if pat.lower() in text:
            return True
    return False


def print_help():
    help_text = dedent(f"""
    {BOLD}lsh - LLM 보조 Linux 쉘 (Python prototype){RESET}

    사용법:
      - 자연어 입력 : LLM이 실행할 명령을 제안합니다.
      - !명령       : LLM 거치지 않고 bash로 바로 실행합니다.
      - bash        : /bin/bash 대화형 셸로 진입합니다.
      - help, ?     : 이 도움말을 보여줍니다.
      - exit, quit, q : lsh 종료.

    환경 변수:
      LSH_LLM_BASE_URL   : LLM 서버 URL (기본: {DEFAULT_BASE_URL})
      LSH_LLM_MODEL      : 모델 이름 (기본: {DEFAULT_MODEL})
      LSH_DANGER_AUTO_CONFIRM=1 : danger=false 인 명령은 자동 실행
      LSH_NO_COLOR=1      : 컬러 출력 비활성화
    """)
    print(help_text)


def fallback_to_bash():
    """현재 프로세스를 /bin/bash로 교체 (login shell용)"""
    try:
        os.execv("/bin/bash", ["/bin/bash"])
    except OSError as e:
        print(f"{YELLOW}[ERR]{RESET} /bin/bash 실행 실패: {e}", file=sys.stderr)
        sys.exit(1)


def is_tty():
    """TTY 여부 확인: 비대화식(scp/cron)일 때는 바로 bash로 폴백"""
    return sys.stdin.isatty()


def main():
    # 비대화식이면 바로 bash로
    if not is_tty():
        fallback_to_bash()

    danger_auto = os.environ.get("LSH_DANGER_AUTO_CONFIRM", "0") == "1"

    print(f"{GREEN}LLM Shell (lsh){RESET} - 자연어 설명 → bash 명령")
    print("  !명령  : LLM 없이 직접 실행")
    print("  help/? : 도움말,  q/quit/exit : 종료")
    print("  bash   : 일반 bash 셸로 진입")
    print()

    while True:
        try:
            prompt = f"{GREEN}lsh>{RESET} "
            text = input(prompt).strip()
        except (EOFError, KeyboardInterrupt):
            print()
            break

        if not text:
            continue

        lower = text.lower()

        # 종료
        if lower in ("q", "quit", "exit"):
            break

        # 도움말
        if text in ("help", "?"):
            print_help()
            continue

        # bash 진입
        if lower == "bash":
            print(f"{CYAN}[INFO]{RESET} /bin/bash 셸로 진입합니다. (exit 로 lsh 종료 가능)")
            subprocess.run("/bin/bash")
            continue

        # !명령 : LLM 없이 바로 실행
        if text.startswith("!"):
            raw_cmd = text[1:].strip()
            if not raw_cmd:
                continue
            print(f"{CYAN}[RUN]{RESET} {raw_cmd}")
            run_shell_command(raw_cmd)
            continue

        # ---------- LLM 경유 모드 ----------
        try:
            plan = call_llm(text)
        except Exception as e:
            print(f"{YELLOW}[ERR]{RESET} LLM 호출 실패: {e}")
            ans = input("그냥 bash로 들어갈까요? [y/N]: ").strip().lower()
            if ans == "y":
                fallback_to_bash()
            continue

        explanation = plan.get("explanation", "")
        commands = plan.get("commands", [])
        llm_danger = bool(plan.get("danger", False))

        if not commands:
            print(f"{YELLOW}[INFO]{RESET} 실행할 명령이 없습니다. (commands 비어 있음)")
            continue

        local_danger = looks_dangerous(commands)
        danger = llm_danger or local_danger

        print(f"\n{GREEN}[PLAN]{RESET} {explanation or '(설명 없음)'}")
        print(f"{CYAN}[CMDS]{RESET}")
        for c in commands:
            print(f"  {GREEN}${RESET} {c}")

        # 실행 여부 확인
        if danger:
            ans = input(f"\n{YELLOW}[경고]{RESET} 위험할 수 있는 명령일 수 있습니다. 정말 실행할까요? [y/N]: ").strip().lower()
            if ans != "y":
                print(f"{YELLOW}[INFO]{RESET} 실행 취소.\n")
                continue
        else:
            if danger_auto:
                ans = "y"
            else:
                ans = input("\n실행할까요? [y/N]: ").strip().lower()
                if ans != "y":
                    print(f"{YELLOW}[INFO]{RESET} 실행 취소.\n")
                    continue

        # 실제 실행
        print()
        for c in commands:
            print(f"{GREEN}▶{RESET} {c}")
            run_shell_command(c)
        print()

    print("bye.")


if __name__ == "__main__":
    main()
